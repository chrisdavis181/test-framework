<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="9" skipped="0" tests="9" time="49.334" timestamp="2024-01-27T01:43:16.109726" hostname="Chriss-MacBook-Air.local"><testcase classname="tests.my_first_test.MyTestClass" name="test_swag_labs" time="4.646"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x0000000102c97f48 chromedriver + 4226888&#10;1   chromedriver                        0x0000000102c904f4 chromedriver + 4195572&#10;2   chromedriver                        0x00000001028d4d68 chromedriver + 281960&#10;3   chromedriver                        0x0000000102900bac chromedriver + 461740&#10;4   chromedriver                        0x00000001028fcfd8 chromedriver + 446424&#10;5   chromedriver                        0x00000001028fa150 chromedriver + 434512&#10;6   chromedriver                        0x000000010293793c chromedriver + 686396&#10;7   chromedriver                        0x0000000102937164 chromedriver + 684388&#10;8   chromedriver                        0x0000000102903f1c chromedriver + 474908&#10;9   chromedriver                        0x0000000102904ef4 chromedriver + 478964&#10;10  chromedriver                        0x0000000102c5959c chromedriver + 3970460&#10;11  chromedriver                        0x0000000102c5d6f0 chromedriver + 3987184&#10;12  chromedriver                        0x0000000102c635b4 chromedriver + 4011444&#10;13  chromedriver                        0x0000000102c5e2fc chromedriver + 3990268&#10;14  chromedriver                        0x0000000102c361c0 chromedriver + 3826112&#10;15  chromedriver                        0x0000000102c7a088 chromedriver + 4104328&#10;16  chromedriver                        0x0000000102c7a1e0 chromedriver + 4104672&#10;17  chromedriver                        0x0000000102c89f28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x106e83390&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106c8d190&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x106e83390&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106c8d190&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x107027c90&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x106e83390&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x107027f90&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x000000010538bf48 chromedriver + 4226888
E       1   chromedriver                        0x00000001053844f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000104fc8d68 chromedriver + 281960
E       3   chromedriver                        0x0000000104fcd114 chromedriver + 299284
E       4   chromedriver                        0x0000000104fcefe4 chromedriver + 307172
E       5   chromedriver                        0x0000000104fcf0d4 chromedriver + 307412
E       6   chromedriver                        0x000000010502c7c4 chromedriver + 690116
E       7   chromedriver                        0x000000010502b164 chromedriver + 684388
E       8   chromedriver                        0x0000000104ff7f1c chromedriver + 474908
E       9   chromedriver                        0x0000000104ff8ef4 chromedriver + 478964
E       10  chromedriver                        0x000000010534d59c chromedriver + 3970460
E       11  chromedriver                        0x00000001053516f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001053575b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001053522fc chromedriver + 3990268
E       14  chromedriver                        0x000000010532a1c0 chromedriver + 3826112
E       15  chromedriver                        0x000000010536e088 chromedriver + 4104328
E       16  chromedriver                        0x000000010536e1e0 chromedriver + 4104672
E       17  chromedriver                        0x000000010537df28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x106fc1f90&gt;
test_case = &lt;tests.my_first_test.MyTestClass testMethod=test_swag_labs&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10704ff90&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x0000000102c97f48 chromedriver + 4226888
E       1   chromedriver                        0x0000000102c904f4 chromedriver + 4195572
E       2   chromedriver                        0x00000001028d4d68 chromedriver + 281960
E       3   chromedriver                        0x0000000102900bac chromedriver + 461740
E       4   chromedriver                        0x00000001028fcfd8 chromedriver + 446424
E       5   chromedriver                        0x00000001028fa150 chromedriver + 434512
E       6   chromedriver                        0x000000010293793c chromedriver + 686396
E       7   chromedriver                        0x0000000102937164 chromedriver + 684388
E       8   chromedriver                        0x0000000102903f1c chromedriver + 474908
E       9   chromedriver                        0x0000000102904ef4 chromedriver + 478964
E       10  chromedriver                        0x0000000102c5959c chromedriver + 3970460
E       11  chromedriver                        0x0000000102c5d6f0 chromedriver + 3987184
E       12  chromedriver                        0x0000000102c635b4 chromedriver + 4011444
E       13  chromedriver                        0x0000000102c5e2fc chromedriver + 3990268
E       14  chromedriver                        0x0000000102c361c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000102c7a088 chromedriver + 4104328
E       16  chromedriver                        0x0000000102c7a1e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000102c89f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.parameterized_test.SearchTests" name="test_parameterized_search_0_SeleniumBase_Commander" time="4.479"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x00000001009fff48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001009f84f4 chromedriver + 4195572&#10;2   chromedriver                        0x000000010063cd68 chromedriver + 281960&#10;3   chromedriver                        0x0000000100668bac chromedriver + 461740&#10;4   chromedriver                        0x0000000100664fd8 chromedriver + 446424&#10;5   chromedriver                        0x0000000100662150 chromedriver + 434512&#10;6   chromedriver                        0x000000010069f93c chromedriver + 686396&#10;7   chromedriver                        0x000000010069f164 chromedriver + 684388&#10;8   chromedriver                        0x000000010066bf1c chromedriver + 474908&#10;9   chromedriver                        0x000000010066cef4 chromedriver + 478964&#10;10  chromedriver                        0x00000001009c159c chromedriver + 3970460&#10;11  chromedriver                        0x00000001009c56f0 chromedriver + 3987184&#10;12  chromedriver                        0x00000001009cb5b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001009c62fc chromedriver + 3990268&#10;14  chromedriver                        0x000000010099e1c0 chromedriver + 3826112&#10;15  chromedriver                        0x00000001009e2088 chromedriver + 4104328&#10;16  chromedriver                        0x00000001009e21e0 chromedriver + 4104672&#10;17  chromedriver                        0x00000001009f1f28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10730dd10&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106d6c890&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10730dd10&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106d6c890&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x10730f710&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10730dd10&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10730eb90&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x0000000102e4ff48 chromedriver + 4226888
E       1   chromedriver                        0x0000000102e484f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000102a8cd68 chromedriver + 281960
E       3   chromedriver                        0x0000000102a91114 chromedriver + 299284
E       4   chromedriver                        0x0000000102a92fe4 chromedriver + 307172
E       5   chromedriver                        0x0000000102a930d4 chromedriver + 307412
E       6   chromedriver                        0x0000000102af07c4 chromedriver + 690116
E       7   chromedriver                        0x0000000102aef164 chromedriver + 684388
E       8   chromedriver                        0x0000000102abbf1c chromedriver + 474908
E       9   chromedriver                        0x0000000102abcef4 chromedriver + 478964
E       10  chromedriver                        0x0000000102e1159c chromedriver + 3970460
E       11  chromedriver                        0x0000000102e156f0 chromedriver + 3987184
E       12  chromedriver                        0x0000000102e1b5b4 chromedriver + 4011444
E       13  chromedriver                        0x0000000102e162fc chromedriver + 3990268
E       14  chromedriver                        0x0000000102dee1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000102e32088 chromedriver + 4104328
E       16  chromedriver                        0x0000000102e321e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000102e41f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x10730e890&gt;
test_case = &lt;tests.parameterized_test.SearchTests testMethod=test_parameterized_search_0_SeleniumBase_Commander&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10730e5d0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x00000001009fff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001009f84f4 chromedriver + 4195572
E       2   chromedriver                        0x000000010063cd68 chromedriver + 281960
E       3   chromedriver                        0x0000000100668bac chromedriver + 461740
E       4   chromedriver                        0x0000000100664fd8 chromedriver + 446424
E       5   chromedriver                        0x0000000100662150 chromedriver + 434512
E       6   chromedriver                        0x000000010069f93c chromedriver + 686396
E       7   chromedriver                        0x000000010069f164 chromedriver + 684388
E       8   chromedriver                        0x000000010066bf1c chromedriver + 474908
E       9   chromedriver                        0x000000010066cef4 chromedriver + 478964
E       10  chromedriver                        0x00000001009c159c chromedriver + 3970460
E       11  chromedriver                        0x00000001009c56f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001009cb5b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001009c62fc chromedriver + 3990268
E       14  chromedriver                        0x000000010099e1c0 chromedriver + 3826112
E       15  chromedriver                        0x00000001009e2088 chromedriver + 4104328
E       16  chromedriver                        0x00000001009e21e0 chromedriver + 4104672
E       17  chromedriver                        0x00000001009f1f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.parameterized_test.SearchTests" name="test_parameterized_search_1_SeleniumBase_Recorder" time="4.542"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x000000010303ff48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001030384f4 chromedriver + 4195572&#10;2   chromedriver                        0x0000000102c7cd68 chromedriver + 281960&#10;3   chromedriver                        0x0000000102ca8bac chromedriver + 461740&#10;4   chromedriver                        0x0000000102ca4fd8 chromedriver + 446424&#10;5   chromedriver                        0x0000000102ca2150 chromedriver + 434512&#10;6   chromedriver                        0x0000000102cdf93c chromedriver + 686396&#10;7   chromedriver                        0x0000000102cdf164 chromedriver + 684388&#10;8   chromedriver                        0x0000000102cabf1c chromedriver + 474908&#10;9   chromedriver                        0x0000000102cacef4 chromedriver + 478964&#10;10  chromedriver                        0x000000010300159c chromedriver + 3970460&#10;11  chromedriver                        0x00000001030056f0 chromedriver + 3987184&#10;12  chromedriver                        0x000000010300b5b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001030062fc chromedriver + 3990268&#10;14  chromedriver                        0x0000000102fde1c0 chromedriver + 3826112&#10;15  chromedriver                        0x0000000103022088 chromedriver + 4104328&#10;16  chromedriver                        0x00000001030221e0 chromedriver + 4104672&#10;17  chromedriver                        0x0000000103031f28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x1073cdad0&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x1073cef50&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x1073cdad0&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x1073cef50&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x1073ccf10&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x1073cdad0&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x1073cf1d0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x000000010503bf48 chromedriver + 4226888
E       1   chromedriver                        0x00000001050344f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000104c78d68 chromedriver + 281960
E       3   chromedriver                        0x0000000104c7d114 chromedriver + 299284
E       4   chromedriver                        0x0000000104c7efe4 chromedriver + 307172
E       5   chromedriver                        0x0000000104c7f0d4 chromedriver + 307412
E       6   chromedriver                        0x0000000104cdc7c4 chromedriver + 690116
E       7   chromedriver                        0x0000000104cdb164 chromedriver + 684388
E       8   chromedriver                        0x0000000104ca7f1c chromedriver + 474908
E       9   chromedriver                        0x0000000104ca8ef4 chromedriver + 478964
E       10  chromedriver                        0x0000000104ffd59c chromedriver + 3970460
E       11  chromedriver                        0x00000001050016f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001050075b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001050022fc chromedriver + 3990268
E       14  chromedriver                        0x0000000104fda1c0 chromedriver + 3826112
E       15  chromedriver                        0x000000010501e088 chromedriver + 4104328
E       16  chromedriver                        0x000000010501e1e0 chromedriver + 4104672
E       17  chromedriver                        0x000000010502df28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x107387910&gt;
test_case = &lt;tests.parameterized_test.SearchTests testMethod=test_parameterized_search_1_SeleniumBase_Recorder&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x1073cd090&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x000000010303ff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001030384f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000102c7cd68 chromedriver + 281960
E       3   chromedriver                        0x0000000102ca8bac chromedriver + 461740
E       4   chromedriver                        0x0000000102ca4fd8 chromedriver + 446424
E       5   chromedriver                        0x0000000102ca2150 chromedriver + 434512
E       6   chromedriver                        0x0000000102cdf93c chromedriver + 686396
E       7   chromedriver                        0x0000000102cdf164 chromedriver + 684388
E       8   chromedriver                        0x0000000102cabf1c chromedriver + 474908
E       9   chromedriver                        0x0000000102cacef4 chromedriver + 478964
E       10  chromedriver                        0x000000010300159c chromedriver + 3970460
E       11  chromedriver                        0x00000001030056f0 chromedriver + 3987184
E       12  chromedriver                        0x000000010300b5b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001030062fc chromedriver + 3990268
E       14  chromedriver                        0x0000000102fde1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000103022088 chromedriver + 4104328
E       16  chromedriver                        0x00000001030221e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000103031f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.parameterized_test.SearchTests" name="test_parameterized_search_2_SeleniumBase_Syntax" time="4.520"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x00000001007abf48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001007a44f4 chromedriver + 4195572&#10;2   chromedriver                        0x00000001003e8d68 chromedriver + 281960&#10;3   chromedriver                        0x0000000100414bac chromedriver + 461740&#10;4   chromedriver                        0x0000000100410fd8 chromedriver + 446424&#10;5   chromedriver                        0x000000010040e150 chromedriver + 434512&#10;6   chromedriver                        0x000000010044b93c chromedriver + 686396&#10;7   chromedriver                        0x000000010044b164 chromedriver + 684388&#10;8   chromedriver                        0x0000000100417f1c chromedriver + 474908&#10;9   chromedriver                        0x0000000100418ef4 chromedriver + 478964&#10;10  chromedriver                        0x000000010076d59c chromedriver + 3970460&#10;11  chromedriver                        0x00000001007716f0 chromedriver + 3987184&#10;12  chromedriver                        0x00000001007775b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001007722fc chromedriver + 3990268&#10;14  chromedriver                        0x000000010074a1c0 chromedriver + 3826112&#10;15  chromedriver                        0x000000010078e088 chromedriver + 4104328&#10;16  chromedriver                        0x000000010078e1e0 chromedriver + 4104672&#10;17  chromedriver                        0x000000010079df28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10cc0b1d0&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106c6c110&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10cc0b1d0&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106c6c110&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x105700510&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10cc0b1d0&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x105700ad0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x0000000100b9ff48 chromedriver + 4226888
E       1   chromedriver                        0x0000000100b984f4 chromedriver + 4195572
E       2   chromedriver                        0x00000001007dcd68 chromedriver + 281960
E       3   chromedriver                        0x00000001007e1114 chromedriver + 299284
E       4   chromedriver                        0x00000001007e2fe4 chromedriver + 307172
E       5   chromedriver                        0x00000001007e30d4 chromedriver + 307412
E       6   chromedriver                        0x00000001008407c4 chromedriver + 690116
E       7   chromedriver                        0x000000010083f164 chromedriver + 684388
E       8   chromedriver                        0x000000010080bf1c chromedriver + 474908
E       9   chromedriver                        0x000000010080cef4 chromedriver + 478964
E       10  chromedriver                        0x0000000100b6159c chromedriver + 3970460
E       11  chromedriver                        0x0000000100b656f0 chromedriver + 3987184
E       12  chromedriver                        0x0000000100b6b5b4 chromedriver + 4011444
E       13  chromedriver                        0x0000000100b662fc chromedriver + 3990268
E       14  chromedriver                        0x0000000100b3e1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000100b82088 chromedriver + 4104328
E       16  chromedriver                        0x0000000100b821e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000100b91f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x10cc08350&gt;
test_case = &lt;tests.parameterized_test.SearchTests testMethod=test_parameterized_search_2_SeleniumBase_Syntax&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10cc09d10&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x00000001007abf48 chromedriver + 4226888
E       1   chromedriver                        0x00000001007a44f4 chromedriver + 4195572
E       2   chromedriver                        0x00000001003e8d68 chromedriver + 281960
E       3   chromedriver                        0x0000000100414bac chromedriver + 461740
E       4   chromedriver                        0x0000000100410fd8 chromedriver + 446424
E       5   chromedriver                        0x000000010040e150 chromedriver + 434512
E       6   chromedriver                        0x000000010044b93c chromedriver + 686396
E       7   chromedriver                        0x000000010044b164 chromedriver + 684388
E       8   chromedriver                        0x0000000100417f1c chromedriver + 474908
E       9   chromedriver                        0x0000000100418ef4 chromedriver + 478964
E       10  chromedriver                        0x000000010076d59c chromedriver + 3970460
E       11  chromedriver                        0x00000001007716f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001007775b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001007722fc chromedriver + 3990268
E       14  chromedriver                        0x000000010074a1c0 chromedriver + 3826112
E       15  chromedriver                        0x000000010078e088 chromedriver + 4104328
E       16  chromedriver                        0x000000010078e1e0 chromedriver + 4104672
E       17  chromedriver                        0x000000010079df28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.test_demo_site.DemoSiteTests" name="test_demo_site" time="4.451"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x00000001032dbf48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001032d44f4 chromedriver + 4195572&#10;2   chromedriver                        0x0000000102f18d68 chromedriver + 281960&#10;3   chromedriver                        0x0000000102f44bac chromedriver + 461740&#10;4   chromedriver                        0x0000000102f40fd8 chromedriver + 446424&#10;5   chromedriver                        0x0000000102f3e150 chromedriver + 434512&#10;6   chromedriver                        0x0000000102f7b93c chromedriver + 686396&#10;7   chromedriver                        0x0000000102f7b164 chromedriver + 684388&#10;8   chromedriver                        0x0000000102f47f1c chromedriver + 474908&#10;9   chromedriver                        0x0000000102f48ef4 chromedriver + 478964&#10;10  chromedriver                        0x000000010329d59c chromedriver + 3970460&#10;11  chromedriver                        0x00000001032a16f0 chromedriver + 3987184&#10;12  chromedriver                        0x00000001032a75b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001032a22fc chromedriver + 3990268&#10;14  chromedriver                        0x000000010327a1c0 chromedriver + 3826112&#10;15  chromedriver                        0x00000001032be088 chromedriver + 4104328&#10;16  chromedriver                        0x00000001032be1e0 chromedriver + 4104672&#10;17  chromedriver                        0x00000001032cdf28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10b83f290&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106d6fe50&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10b83f290&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106d6fe50&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x106d6e190&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10b83f290&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x106d6d090&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x000000010102ff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001010284f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000100c6cd68 chromedriver + 281960
E       3   chromedriver                        0x0000000100c71114 chromedriver + 299284
E       4   chromedriver                        0x0000000100c72fe4 chromedriver + 307172
E       5   chromedriver                        0x0000000100c730d4 chromedriver + 307412
E       6   chromedriver                        0x0000000100cd07c4 chromedriver + 690116
E       7   chromedriver                        0x0000000100ccf164 chromedriver + 684388
E       8   chromedriver                        0x0000000100c9bf1c chromedriver + 474908
E       9   chromedriver                        0x0000000100c9cef4 chromedriver + 478964
E       10  chromedriver                        0x0000000100ff159c chromedriver + 3970460
E       11  chromedriver                        0x0000000100ff56f0 chromedriver + 3987184
E       12  chromedriver                        0x0000000100ffb5b4 chromedriver + 4011444
E       13  chromedriver                        0x0000000100ff62fc chromedriver + 3990268
E       14  chromedriver                        0x0000000100fce1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000101012088 chromedriver + 4104328
E       16  chromedriver                        0x00000001010121e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000101021f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x10b83c490&gt;
test_case = &lt;tests.test_demo_site.DemoSiteTests testMethod=test_demo_site&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10b83f110&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x00000001032dbf48 chromedriver + 4226888
E       1   chromedriver                        0x00000001032d44f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000102f18d68 chromedriver + 281960
E       3   chromedriver                        0x0000000102f44bac chromedriver + 461740
E       4   chromedriver                        0x0000000102f40fd8 chromedriver + 446424
E       5   chromedriver                        0x0000000102f3e150 chromedriver + 434512
E       6   chromedriver                        0x0000000102f7b93c chromedriver + 686396
E       7   chromedriver                        0x0000000102f7b164 chromedriver + 684388
E       8   chromedriver                        0x0000000102f47f1c chromedriver + 474908
E       9   chromedriver                        0x0000000102f48ef4 chromedriver + 478964
E       10  chromedriver                        0x000000010329d59c chromedriver + 3970460
E       11  chromedriver                        0x00000001032a16f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001032a75b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001032a22fc chromedriver + 3990268
E       14  chromedriver                        0x000000010327a1c0 chromedriver + 3826112
E       15  chromedriver                        0x00000001032be088 chromedriver + 4104328
E       16  chromedriver                        0x00000001032be1e0 chromedriver + 4104672
E       17  chromedriver                        0x00000001032cdf28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.boilerplates.boilerplate_test.MyTestClass" name="test_boilerplate" time="4.445"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x00000001046cff48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001046c84f4 chromedriver + 4195572&#10;2   chromedriver                        0x000000010430cd68 chromedriver + 281960&#10;3   chromedriver                        0x0000000104338bac chromedriver + 461740&#10;4   chromedriver                        0x0000000104334fd8 chromedriver + 446424&#10;5   chromedriver                        0x0000000104332150 chromedriver + 434512&#10;6   chromedriver                        0x000000010436f93c chromedriver + 686396&#10;7   chromedriver                        0x000000010436f164 chromedriver + 684388&#10;8   chromedriver                        0x000000010433bf1c chromedriver + 474908&#10;9   chromedriver                        0x000000010433cef4 chromedriver + 478964&#10;10  chromedriver                        0x000000010469159c chromedriver + 3970460&#10;11  chromedriver                        0x00000001046956f0 chromedriver + 3987184&#10;12  chromedriver                        0x000000010469b5b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001046962fc chromedriver + 3990268&#10;14  chromedriver                        0x000000010466e1c0 chromedriver + 3826112&#10;15  chromedriver                        0x00000001046b2088 chromedriver + 4104328&#10;16  chromedriver                        0x00000001046b21e0 chromedriver + 4104672&#10;17  chromedriver                        0x00000001046c1f28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x107579c90&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x105450a10&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x107579c90&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x105450a10&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x1075795d0&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x107579c90&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x107579650&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x0000000100aa7f48 chromedriver + 4226888
E       1   chromedriver                        0x0000000100aa04f4 chromedriver + 4195572
E       2   chromedriver                        0x00000001006e4d68 chromedriver + 281960
E       3   chromedriver                        0x00000001006e9114 chromedriver + 299284
E       4   chromedriver                        0x00000001006eafe4 chromedriver + 307172
E       5   chromedriver                        0x00000001006eb0d4 chromedriver + 307412
E       6   chromedriver                        0x00000001007487c4 chromedriver + 690116
E       7   chromedriver                        0x0000000100747164 chromedriver + 684388
E       8   chromedriver                        0x0000000100713f1c chromedriver + 474908
E       9   chromedriver                        0x0000000100714ef4 chromedriver + 478964
E       10  chromedriver                        0x0000000100a6959c chromedriver + 3970460
E       11  chromedriver                        0x0000000100a6d6f0 chromedriver + 3987184
E       12  chromedriver                        0x0000000100a735b4 chromedriver + 4011444
E       13  chromedriver                        0x0000000100a6e2fc chromedriver + 3990268
E       14  chromedriver                        0x0000000100a461c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000100a8a088 chromedriver + 4104328
E       16  chromedriver                        0x0000000100a8a1e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000100a99f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x10757b650&gt;
test_case = &lt;tests.boilerplates.boilerplate_test.MyTestClass testMethod=test_boilerplate&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
tests/boilerplates/base_test_case.py:7: in setUp
    super().setUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10757a550&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x00000001046cff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001046c84f4 chromedriver + 4195572
E       2   chromedriver                        0x000000010430cd68 chromedriver + 281960
E       3   chromedriver                        0x0000000104338bac chromedriver + 461740
E       4   chromedriver                        0x0000000104334fd8 chromedriver + 446424
E       5   chromedriver                        0x0000000104332150 chromedriver + 434512
E       6   chromedriver                        0x000000010436f93c chromedriver + 686396
E       7   chromedriver                        0x000000010436f164 chromedriver + 684388
E       8   chromedriver                        0x000000010433bf1c chromedriver + 474908
E       9   chromedriver                        0x000000010433cef4 chromedriver + 478964
E       10  chromedriver                        0x000000010469159c chromedriver + 3970460
E       11  chromedriver                        0x00000001046956f0 chromedriver + 3987184
E       12  chromedriver                        0x000000010469b5b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001046962fc chromedriver + 3990268
E       14  chromedriver                        0x000000010466e1c0 chromedriver + 3826112
E       15  chromedriver                        0x00000001046b2088 chromedriver + 4104328
E       16  chromedriver                        0x00000001046b21e0 chromedriver + 4104672
E       17  chromedriver                        0x00000001046c1f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.boilerplates.classic_obj_test.ObjTests" name="test_data_url_page" time="4.496"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x000000010086bf48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001008644f4 chromedriver + 4195572&#10;2   chromedriver                        0x00000001004a8d68 chromedriver + 281960&#10;3   chromedriver                        0x00000001004d4bac chromedriver + 461740&#10;4   chromedriver                        0x00000001004d0fd8 chromedriver + 446424&#10;5   chromedriver                        0x00000001004ce150 chromedriver + 434512&#10;6   chromedriver                        0x000000010050b93c chromedriver + 686396&#10;7   chromedriver                        0x000000010050b164 chromedriver + 684388&#10;8   chromedriver                        0x00000001004d7f1c chromedriver + 474908&#10;9   chromedriver                        0x00000001004d8ef4 chromedriver + 478964&#10;10  chromedriver                        0x000000010082d59c chromedriver + 3970460&#10;11  chromedriver                        0x00000001008316f0 chromedriver + 3987184&#10;12  chromedriver                        0x00000001008375b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001008322fc chromedriver + 3990268&#10;14  chromedriver                        0x000000010080a1c0 chromedriver + 3826112&#10;15  chromedriver                        0x000000010084e088 chromedriver + 4104328&#10;16  chromedriver                        0x000000010084e1e0 chromedriver + 4104672&#10;17  chromedriver                        0x000000010085df28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10704c750&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x10704d690&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10704c750&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x10704d690&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x10704c510&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10704c750&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10704cad0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x00000001024cbf48 chromedriver + 4226888
E       1   chromedriver                        0x00000001024c44f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000102108d68 chromedriver + 281960
E       3   chromedriver                        0x000000010210d114 chromedriver + 299284
E       4   chromedriver                        0x000000010210efe4 chromedriver + 307172
E       5   chromedriver                        0x000000010210f0d4 chromedriver + 307412
E       6   chromedriver                        0x000000010216c7c4 chromedriver + 690116
E       7   chromedriver                        0x000000010216b164 chromedriver + 684388
E       8   chromedriver                        0x0000000102137f1c chromedriver + 474908
E       9   chromedriver                        0x0000000102138ef4 chromedriver + 478964
E       10  chromedriver                        0x000000010248d59c chromedriver + 3970460
E       11  chromedriver                        0x00000001024916f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001024975b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001024922fc chromedriver + 3990268
E       14  chromedriver                        0x000000010246a1c0 chromedriver + 3826112
E       15  chromedriver                        0x00000001024ae088 chromedriver + 4104328
E       16  chromedriver                        0x00000001024ae1e0 chromedriver + 4104672
E       17  chromedriver                        0x00000001024bdf28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x10704cf10&gt;
test_case = &lt;tests.boilerplates.classic_obj_test.ObjTests testMethod=test_data_url_page&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10c7d9b90&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x000000010086bf48 chromedriver + 4226888
E       1   chromedriver                        0x00000001008644f4 chromedriver + 4195572
E       2   chromedriver                        0x00000001004a8d68 chromedriver + 281960
E       3   chromedriver                        0x00000001004d4bac chromedriver + 461740
E       4   chromedriver                        0x00000001004d0fd8 chromedriver + 446424
E       5   chromedriver                        0x00000001004ce150 chromedriver + 434512
E       6   chromedriver                        0x000000010050b93c chromedriver + 686396
E       7   chromedriver                        0x000000010050b164 chromedriver + 684388
E       8   chromedriver                        0x00000001004d7f1c chromedriver + 474908
E       9   chromedriver                        0x00000001004d8ef4 chromedriver + 478964
E       10  chromedriver                        0x000000010082d59c chromedriver + 3970460
E       11  chromedriver                        0x00000001008316f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001008375b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001008322fc chromedriver + 3990268
E       14  chromedriver                        0x000000010080a1c0 chromedriver + 3826112
E       15  chromedriver                        0x000000010084e088 chromedriver + 4104328
E       16  chromedriver                        0x000000010084e1e0 chromedriver + 4104672
E       17  chromedriver                        0x000000010085df28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.boilerplates.samples.google_test.GoogleTests" name="test_google_dot_com" time="4.485"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x000000010530ff48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001053084f4 chromedriver + 4195572&#10;2   chromedriver                        0x0000000104f4cd68 chromedriver + 281960&#10;3   chromedriver                        0x0000000104f78bac chromedriver + 461740&#10;4   chromedriver                        0x0000000104f74fd8 chromedriver + 446424&#10;5   chromedriver                        0x0000000104f72150 chromedriver + 434512&#10;6   chromedriver                        0x0000000104faf93c chromedriver + 686396&#10;7   chromedriver                        0x0000000104faf164 chromedriver + 684388&#10;8   chromedriver                        0x0000000104f7bf1c chromedriver + 474908&#10;9   chromedriver                        0x0000000104f7cef4 chromedriver + 478964&#10;10  chromedriver                        0x00000001052d159c chromedriver + 3970460&#10;11  chromedriver                        0x00000001052d56f0 chromedriver + 3987184&#10;12  chromedriver                        0x00000001052db5b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001052d62fc chromedriver + 3990268&#10;14  chromedriver                        0x00000001052ae1c0 chromedriver + 3826112&#10;15  chromedriver                        0x00000001052f2088 chromedriver + 4104328&#10;16  chromedriver                        0x00000001052f21e0 chromedriver + 4104672&#10;17  chromedriver                        0x0000000105301f28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x1073cf3d0&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x1073cdb10&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x1073cf3d0&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x1073cdb10&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x1073cd9d0&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x1073cf3d0&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x1073cce50&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x000000010058ff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001005884f4 chromedriver + 4195572
E       2   chromedriver                        0x00000001001ccd68 chromedriver + 281960
E       3   chromedriver                        0x00000001001d1114 chromedriver + 299284
E       4   chromedriver                        0x00000001001d2fe4 chromedriver + 307172
E       5   chromedriver                        0x00000001001d30d4 chromedriver + 307412
E       6   chromedriver                        0x00000001002307c4 chromedriver + 690116
E       7   chromedriver                        0x000000010022f164 chromedriver + 684388
E       8   chromedriver                        0x00000001001fbf1c chromedriver + 474908
E       9   chromedriver                        0x00000001001fcef4 chromedriver + 478964
E       10  chromedriver                        0x000000010055159c chromedriver + 3970460
E       11  chromedriver                        0x00000001005556f0 chromedriver + 3987184
E       12  chromedriver                        0x000000010055b5b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001005562fc chromedriver + 3990268
E       14  chromedriver                        0x000000010052e1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000100572088 chromedriver + 4104328
E       16  chromedriver                        0x00000001005721e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000100581f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x1073cf510&gt;
test_case = &lt;tests.boilerplates.samples.google_test.GoogleTests testMethod=test_google_dot_com&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10b81f4d0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x000000010530ff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001053084f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000104f4cd68 chromedriver + 281960
E       3   chromedriver                        0x0000000104f78bac chromedriver + 461740
E       4   chromedriver                        0x0000000104f74fd8 chromedriver + 446424
E       5   chromedriver                        0x0000000104f72150 chromedriver + 434512
E       6   chromedriver                        0x0000000104faf93c chromedriver + 686396
E       7   chromedriver                        0x0000000104faf164 chromedriver + 684388
E       8   chromedriver                        0x0000000104f7bf1c chromedriver + 474908
E       9   chromedriver                        0x0000000104f7cef4 chromedriver + 478964
E       10  chromedriver                        0x00000001052d159c chromedriver + 3970460
E       11  chromedriver                        0x00000001052d56f0 chromedriver + 3987184
E       12  chromedriver                        0x00000001052db5b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001052d62fc chromedriver + 3990268
E       14  chromedriver                        0x00000001052ae1c0 chromedriver + 3826112
E       15  chromedriver                        0x00000001052f2088 chromedriver + 4104328
E       16  chromedriver                        0x00000001052f21e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000105301f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase><testcase classname="tests.boilerplates.samples.swag_labs_test.MyTests" name="test_swag_labs_login" time="4.477"><failure message="selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114&#10;Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#10;Stacktrace:&#10;0   chromedriver                        0x000000010253ff48 chromedriver + 4226888&#10;1   chromedriver                        0x00000001025384f4 chromedriver + 4195572&#10;2   chromedriver                        0x000000010217cd68 chromedriver + 281960&#10;3   chromedriver                        0x00000001021a8bac chromedriver + 461740&#10;4   chromedriver                        0x00000001021a4fd8 chromedriver + 446424&#10;5   chromedriver                        0x00000001021a2150 chromedriver + 434512&#10;6   chromedriver                        0x00000001021df93c chromedriver + 686396&#10;7   chromedriver                        0x00000001021df164 chromedriver + 684388&#10;8   chromedriver                        0x00000001021abf1c chromedriver + 474908&#10;9   chromedriver                        0x00000001021acef4 chromedriver + 478964&#10;10  chromedriver                        0x000000010250159c chromedriver + 3970460&#10;11  chromedriver                        0x00000001025056f0 chromedriver + 3987184&#10;12  chromedriver                        0x000000010250b5b4 chromedriver + 4011444&#10;13  chromedriver                        0x00000001025062fc chromedriver + 3990268&#10;14  chromedriver                        0x00000001024de1c0 chromedriver + 3826112&#10;15  chromedriver                        0x0000000102522088 chromedriver + 4104328&#10;16  chromedriver                        0x00000001025221e0 chromedriver + 4104672&#10;17  chromedriver                        0x0000000102531f28 chromedriver + 4169512&#10;18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136&#10;19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8">browser_name = 'chrome', headless = False, locale_code = None, servername = 'localhost', proxy_string = None, proxy_auth = False
proxy_user = None, proxy_pass = None, proxy_bypass_list = None, proxy_pac_url = None, multi_proxy = False, user_agent = None
recorder_ext = False, disable_js = False, disable_csp = False, enable_ws = True, enable_sync = False, use_auto_ext = False
undetectable = False, uc_cdp_events = None, uc_subprocess = None, no_sandbox = False, disable_gpu = False, headless2 = False
incognito = False, guest_mode = False, devtools = False, remote_debug = False, enable_3d_apis = False, swiftshader = False
ad_block_on = False, block_images = False, do_not_track = False, chromium_arg = None, firefox_arg = None, firefox_pref = None
user_data_dir = None, extension_zip = None, extension_dir = None, binary_location = None, page_load_strategy = None, use_wire = False
external_pdf = False, mobile_emulator = False, device_width = None, device_height = None, device_pixel_ratio = None

    def get_local_driver(
        browser_name,
        headless,
        locale_code,
        servername,
        proxy_string,
        proxy_auth,
        proxy_user,
        proxy_pass,
        proxy_bypass_list,
        proxy_pac_url,
        multi_proxy,
        user_agent,
        recorder_ext,
        disable_js,
        disable_csp,
        enable_ws,
        enable_sync,
        use_auto_ext,
        undetectable,
        uc_cdp_events,
        uc_subprocess,
        no_sandbox,
        disable_gpu,
        headless2,
        incognito,
        guest_mode,
        devtools,
        remote_debug,
        enable_3d_apis,
        swiftshader,
        ad_block_on,
        block_images,
        do_not_track,
        chromium_arg,
        firefox_arg,
        firefox_pref,
        user_data_dir,
        extension_zip,
        extension_dir,
        binary_location,
        page_load_strategy,
        use_wire,
        external_pdf,
        mobile_emulator,
        device_width,
        device_height,
        device_pixel_ratio,
    ):
        """Spins up a new web browser and returns the driver.
        Can also be used to spin up additional browsers for the same test."""
        downloads_path = DOWNLOADS_FOLDER
        b_path = binary_location
        if use_wire and selenium4_or_newer:
            driver_fixing_lock = fasteners.InterProcessLock(
                constants.MultiBrowser.DRIVER_FIXING_LOCK
            )
            with driver_fixing_lock:  # Prevent multi-processes mode issues
                try:
                    from seleniumwire import webdriver
                except Exception:
                    shared_utils.pip_install(
                        "selenium-wire", version=constants.SeleniumWire.VER
                    )
                    from seleniumwire import webdriver
        else:
            from selenium import webdriver
    
        if browser_name == constants.Browser.FIREFOX:
            firefox_options = _set_firefox_options(
                downloads_path,
                headless,
                locale_code,
                proxy_string,
                proxy_bypass_list,
                proxy_pac_url,
                user_agent,
                disable_js,
                disable_csp,
                firefox_arg,
                firefox_pref,
            )
            if LOCAL_GECKODRIVER and os.path.exists(LOCAL_GECKODRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_GECKODRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make geckodriver"
                        " executable: %s" % e
                    )
            elif not geckodriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: geckodriver not found. Getting it now:")
                    try:
                        sb_install.main(override="geckodriver")
                    except Exception as e:
                        print("\nWarning: Could not install geckodriver: %s" % e)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    geckodriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with geckodriver_fixing_lock:
                        if not geckodriver_on_path():
                            sys_args = sys.argv  # Save a copy of sys args
                            print(
                                "\nWarning: geckodriver not found. "
                                "Getting it now:"
                            )
                            sb_install.main(override="geckodriver")
                            sys.argv = sys_args  # Put back original sys args
            # Launch Firefox
            if os.path.exists(LOCAL_GECKODRIVER):
                if selenium4_or_newer:
                    service = FirefoxService(
                        executable_path=LOCAL_GECKODRIVER,
                        log_path=os.devnull,
                    )
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        executable_path=LOCAL_GECKODRIVER,
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
            else:
                if selenium4_or_newer:
                    service = FirefoxService(log_path=os.devnull)
                    try:
                        return webdriver.Firefox(
                            service=service,
                            options=firefox_options,
                        )
                    except BaseException as e:
                        if (
                            "geckodriver unexpectedly exited" in str(e)
                            or "Process unexpectedly closed" in str(e)
                            or "Failed to read marionette port" in str(e)
                            or "A connection attempt failed" in str(e)
                            or hasattr(e, "msg") and (
                                "geckodriver unexpectedly exited" in e.msg
                                or "Process unexpectedly closed" in e.msg
                                or "Failed to read marionette port" in e.msg
                                or "A connection attempt failed" in e.msg
                            )
                        ):
                            time.sleep(0.1)
                            if (
                                IS_LINUX
                                and headless
                                and (
                                    "unexpected" in str(e)
                                    or (
                                        hasattr(e, "msg") and "unexpected" in e.msg
                                    )
                                )
                            ):
                                firefox_options.add_argument("-headless")
                            return webdriver.Firefox(
                                service=service,
                                options=firefox_options,
                            )
                        else:
                            raise  # Not an obvious fix.
                else:
                    return webdriver.Firefox(
                        service_log_path=os.devnull,
                        options=firefox_options,
                    )
        elif browser_name == constants.Browser.INTERNET_EXPLORER:
            if not IS_WINDOWS:
                raise Exception(
                    "IE Browser is for Windows-based operating systems only!"
                )
            from selenium.webdriver.ie.options import Options
    
            ie_options = Options()
            ie_options.ignore_protected_mode_settings = True
            ie_options.ignore_zoom_level = True
            ie_options.require_window_focus = False
            ie_options.native_events = True
            ie_options.full_page_screenshot = True
            ie_options.persistent_hover = True
            ie_capabilities = ie_options.to_capabilities()
            if LOCAL_IEDRIVER and os.path.exists(LOCAL_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make IEDriver executable: %s" % e
                    )
            elif not iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: IEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if LOCAL_HEADLESS_IEDRIVER and os.path.exists(LOCAL_HEADLESS_IEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_HEADLESS_IEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make HeadlessIEDriver executable: %s"
                        % e
                    )
            elif not headless_iedriver_on_path():
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\nWarning: HeadlessIEDriver not found. Getting it now:")
                    sb_install.main(override="iedriver")
                    sys.argv = sys_args  # Put back the original sys args
            if not headless:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(capabilities=ie_capabilities)
            else:
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Ie(
                    executable_path=LOCAL_HEADLESS_IEDRIVER,
                    capabilities=ie_capabilities,
                )
        elif browser_name == constants.Browser.EDGE:
            prefs = {
                "download.default_directory": downloads_path,
                "local_discovery.notifications_enabled": False,
                "credentials_enable_service": False,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": False,
                "safebrowsing.disable_download_protection": True,
                "default_content_setting_values.notifications": 0,
                "default_content_settings.popups": 0,
                "managed_default_content_settings.popups": 0,
                "content_settings.exceptions.automatic_downloads.*.setting": 1,
                "profile.password_manager_enabled": False,
                "profile.default_content_setting_values.notifications": 2,
                "profile.default_content_settings.popups": 0,
                "profile.managed_default_content_settings.popups": 0,
                "profile.default_content_setting_values.automatic_downloads": 1,
            }
            use_version = "latest"
            major_edge_version = None
            try:
                from seleniumbase.core import detect_b_ver
    
                if binary_location:
                    try:
                        major_edge_version = (
                            detect_b_ver.get_browser_version_from_binary(
                                binary_location
                            )
                        ).split(".")[0]
                        if len(major_edge_version) &lt; 2:
                            major_edge_version = None
                    except Exception:
                        major_edge_version = None
                if not major_edge_version:
                    br_app = "edge"
                    major_edge_version = (
                        detect_b_ver.get_browser_version_from_os(br_app)
                    ).split(".")[0]
                if int(major_edge_version) &lt; 80:
                    major_edge_version = None
            except Exception:
                major_edge_version = None
            if major_edge_version:
                use_version = major_edge_version
            driver_version = None
            if os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    output = subprocess.check_output(
                        "%s --version" % LOCAL_EDGEDRIVER, shell=True
                    )
                    if IS_WINDOWS:
                        output = output.decode("latin1")
                    else:
                        output = output.decode("utf-8")
                    if output.split(" ")[0] == "MSEdgeDriver":
                        # MSEdgeDriver VERSION
                        output = output.split(" ")[1].split(".")[0]
                    elif output.split(" ")[0] == "Microsoft":
                        # Microsoft Edge WebDriver VERSION
                        output = output.split(" ")[3].split(".")[0]
                    else:
                        output = 0
                    if int(output) &gt;= 2:
                        driver_version = output
                except Exception:
                    pass
            edgedriver_upgrade_needed = False
            local_edgedriver_exists = False
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                local_edgedriver_exists = True
                if (
                    use_version != "latest"
                    and driver_version
                    and use_version != driver_version
                ):
                    edgedriver_upgrade_needed = True
                else:
                    try:
                        make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make edgedriver"
                            " executable: %s" % e
                        )
            if not local_edgedriver_exists or edgedriver_upgrade_needed:
                from seleniumbase.console_scripts import sb_install
    
                args = " ".join(sys.argv)
                if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    # (Not multithreaded)
                    msg = "Microsoft Edge Driver not found."
                    if edgedriver_upgrade_needed:
                        msg = "Microsoft Edge Driver update needed."
                    sys_args = sys.argv  # Save a copy of current sys args
                    print("\n%s Getting it now:" % msg)
                    sb_install.main(override="edgedriver %s" % use_version)
                    sys.argv = sys_args  # Put back the original sys args
                else:
                    edgedriver_fixing_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with edgedriver_fixing_lock:
                        msg = "Microsoft Edge Driver not found."
                        if edgedriver_upgrade_needed:
                            msg = "Microsoft Edge Driver update needed."
                        sys_args = sys.argv  # Save a copy of current sys args
                        print("\n%s Getting it now:" % msg)
                        sb_install.main(override="edgedriver %s" % use_version)
                        sys.argv = sys_args  # Put back the original sys args
    
            # For Microsoft Edge (Chromium) version 80 or higher
            if selenium4_or_newer:
                Edge = webdriver.edge.webdriver.WebDriver
                EdgeOptions = webdriver.edge.webdriver.Options
            else:
                from msedge.selenium_tools import Edge, EdgeOptions
    
            if LOCAL_EDGEDRIVER and os.path.exists(LOCAL_EDGEDRIVER):
                try:
                    make_driver_executable_if_not(LOCAL_EDGEDRIVER)
                except Exception as e:
                    logging.debug(
                        "\nWarning: Could not make edgedriver"
                        " executable: %s" % e
                    )
            edge_options = EdgeOptions()
            edge_options.use_chromium = True
            if locale_code:
                prefs["intl.accept_languages"] = locale_code
            if block_images:
                prefs["profile.managed_default_content_settings.images"] = 2
            if disable_js:
                prefs["profile.managed_default_content_settings.javascript"] = 2
            if do_not_track:
                prefs["enable_do_not_track"] = True
            if external_pdf:
                prefs["plugins.always_open_pdf_externally"] = True
            edge_options.add_experimental_option("prefs", prefs)
            if not selenium4_or_newer:
                edge_options.add_experimental_option("w3c", True)
            edge_options.add_argument(
                "--disable-blink-features=AutomationControlled"
            )
            edge_options.add_experimental_option(
                "excludeSwitches", ["enable-automation", "enable-logging"]
            )
            if not enable_sync:
                edge_options.add_argument("--disable-sync")
            if guest_mode or IS_WINDOWS:
                edge_options.add_argument("--guest")
            if headless2:
                try:
                    if use_version == "latest" or int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    else:
                        edge_options.add_argument("--headless=chrome")
                except Exception:
                    edge_options.add_argument("--headless=new")
            elif headless and undetectable:
                # (For later: UC Mode doesn't support Edge now)
                try:
                    if int(use_version) &gt;= 109:
                        edge_options.add_argument("--headless=new")
                    elif (
                        int(use_version) &gt;= 96
                        and int(use_version) &lt;= 108
                    ):
                        edge_options.add_argument("--headless=chrome")
                    else:
                        pass  # Will need Xvfb on Linux
                except Exception:
                    pass
            elif headless:
                if "--headless" not in edge_options.arguments:
                    edge_options.add_argument("--headless")
            if mobile_emulator:
                emulator_settings = {}
                device_metrics = {}
                if (
                    type(device_width) is int
                    and type(device_height) is int
                    and type(device_pixel_ratio) is int
                ):
                    device_metrics["width"] = device_width
                    device_metrics["height"] = device_height
                    device_metrics["pixelRatio"] = device_pixel_ratio
                else:
                    device_metrics["width"] = 360
                    device_metrics["height"] = 640
                    device_metrics["pixelRatio"] = 2
                emulator_settings["deviceMetrics"] = device_metrics
                if user_agent:
                    emulator_settings["userAgent"] = user_agent
                edge_options.add_experimental_option(
                    "mobileEmulation", emulator_settings
                )
            if headless or headless2:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.HEADLESS_START_WIDTH,
                        settings.HEADLESS_START_HEIGHT,
                    )
                )
            else:
                edge_options.add_argument(
                    "--window-size=%s,%s" % (
                        settings.CHROME_START_WIDTH,
                        settings.CHROME_START_HEIGHT,
                    )
                )
            if user_data_dir and not is_using_uc(undetectable, browser_name):
                abs_path = os.path.abspath(user_data_dir)
                edge_options.add_argument("user-data-dir=%s" % abs_path)
            if extension_zip:
                # Can be a comma-separated list of .ZIP or .CRX files
                extension_zip_list = extension_zip.split(",")
                for extension_zip_item in extension_zip_list:
                    abs_path = os.path.abspath(extension_zip_item)
                    edge_options.add_extension(abs_path)
            if extension_dir:
                # load-extension input can be a comma-separated list
                abs_path = os.path.abspath(extension_dir)
                edge_options = add_chrome_ext_dir(edge_options, abs_path)
            edge_options.add_argument("--disable-infobars")
            edge_options.add_argument("--disable-notifications")
            edge_options.add_argument("--disable-save-password-bubble")
            edge_options.add_argument("--disable-single-click-autofill")
            edge_options.add_argument(
                "--disable-autofill-keyboard-accessory-view[8]"
            )
            edge_options.add_argument("--disable-browser-side-navigation")
            edge_options.add_argument("--disable-translate")
            if binary_location:
                edge_options.binary_location = binary_location
            if not enable_ws:
                edge_options.add_argument("--disable-web-security")
            edge_options.add_argument("--homepage=about:blank")
            edge_options.add_argument("--dns-prefetch-disable")
            edge_options.add_argument("--dom-automation")
            edge_options.add_argument("--disable-hang-monitor")
            edge_options.add_argument("--disable-prompt-on-repost")
            if not enable_3d_apis:
                edge_options.add_argument("--disable-3d-apis")
            if headless or headless2 or is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--disable-renderer-backgrounding")
            edge_options.add_argument("--disable-backgrounding-occluded-windows")
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                edge_options.page_load_strategy = (
                    settings.PAGE_LOAD_STRATEGY.lower()
                )
            if (settings.DISABLE_CSP_ON_CHROME or disable_csp) and not headless:
                # Headless Edge doesn't support extensions, which are required
                # for disabling the Content Security Policy on Edge
                edge_options = _add_chrome_disable_csp_extension(edge_options)
            if ad_block_on and not headless:
                edge_options = _add_chrome_ad_block_extension(edge_options)
            if recorder_ext and not headless:
                edge_options = _add_chrome_recorder_extension(edge_options)
            if proxy_string:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        proxy_string,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-server=%s" % proxy_string)
                if proxy_bypass_list:
                    edge_options.add_argument(
                        "--proxy-bypass-list=%s" % proxy_bypass_list
                    )
            elif proxy_pac_url:
                if proxy_auth:
                    edge_options = _add_chrome_proxy_extension(
                        edge_options,
                        None,
                        proxy_user,
                        proxy_pass,
                        zip_it=True,
                        multi_proxy=multi_proxy,
                    )
                edge_options.add_argument("--proxy-pac-url=%s" % proxy_pac_url)
            edge_options.add_argument("--test-type")
            edge_options.add_argument("--log-level=3")
            edge_options.add_argument("--no-first-run")
            edge_options.add_argument("--ignore-certificate-errors")
            if devtools and not headless:
                edge_options.add_argument("--auto-open-devtools-for-tabs")
            edge_options.add_argument("--allow-file-access-from-files")
            edge_options.add_argument("--allow-insecure-localhost")
            edge_options.add_argument("--allow-running-insecure-content")
            if user_agent:
                edge_options.add_argument("--user-agent=%s" % user_agent)
            if IS_LINUX or not is_using_uc(undetectable, browser_name):
                edge_options.add_argument("--no-sandbox")
            if remote_debug:
                # To access the Debugger, go to: edge://inspect/#devices
                # while a Chromium driver is running.
                # Info: https://chromedevtools.github.io/devtools-protocol/
                sys_argv = sys.argv
                arg_join = " ".join(sys_argv)
                free_port = 9222
                if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                    free_port = service_utils.free_port()
                edge_options.add_argument("--remote-debugging-port=%s" % free_port)
            if swiftshader:
                edge_options.add_argument("--use-gl=swiftshader")
            else:
                edge_options.add_argument("--disable-gpu")
            if IS_LINUX:
                edge_options.add_argument("--disable-dev-shm-usage")
            if chromium_arg:
                # Can be a comma-separated list of Chromium args
                chromium_arg_list = chromium_arg.split(",")
                for chromium_arg_item in chromium_arg_list:
                    chromium_arg_item = chromium_arg_item.strip()
                    if not chromium_arg_item.startswith("--"):
                        if chromium_arg_item.startswith("-"):
                            chromium_arg_item = "-" + chromium_arg_item
                        else:
                            chromium_arg_item = "--" + chromium_arg_item
                    if len(chromium_arg_item) &gt;= 3:
                        edge_options.add_argument(chromium_arg_item)
            if selenium4_or_newer:
                try:
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER, log_path=os.devnull
                    )
                    driver = Edge(service=service, options=edge_options)
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            try:
                                if not _was_driver_repaired():
                                    _repair_edgedriver(edge_version)
                                    _mark_driver_repaired()
                            except Exception:
                                pass
                    else:
                        try:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                            _mark_driver_repaired()
                        except Exception:
                            pass
                    service = EdgeService(
                        executable_path=LOCAL_EDGEDRIVER,
                        log_path=os.devnull,
                        service_args=["--disable-build-check"],
                    )
                    driver = Edge(service=service, options=edge_options)
                return driver
            else:
                capabilities = edge_options.to_capabilities()
                capabilities["platform"] = ""
                try:
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        capabilities=capabilities,
                    )
                except Exception as e:
                    if not hasattr(e, "msg"):
                        raise
                    auto_upgrade_edgedriver = False
                    edge_version = None
                    if (
                        "This version of MSEdgeDriver only supports" in e.msg
                        or "This version of Microsoft Edge WebDriver" in e.msg
                    ):
                        if "Current browser version is " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "Current browser version is "
                            )[1].split(" ")[0]
                        elif "only supports MSEdge version " in e.msg:
                            auto_upgrade_edgedriver = True
                            edge_version = e.msg.split(
                                "only supports MSEdge version "
                            )[1].split(" ")[0]
                    elif "DevToolsActivePort file doesn't exist" in e.msg:
                        service = EdgeService(
                            executable_path=LOCAL_EDGEDRIVER,
                            log_path=os.devnull,
                        )
                        # https://stackoverflow.com/a/56638103/7058266
                        sys_argv = sys.argv
                        arg_join = " ".join(sys_argv)
                        free_port = 9222
                        if ("-n" in sys.argv or " -n=" in args or args == "-c"):
                            free_port = service_utils.free_port()
                        edge_options.add_argument(
                            "--remote-debugging-port=%s" % free_port
                        )
                        return Edge(service=service, options=edge_options)
                    if not auto_upgrade_edgedriver:
                        raise  # Not an obvious fix.
                    else:
                        pass  # Try upgrading EdgeDriver to match Edge.
                    args = " ".join(sys.argv)
                    if "-n" in sys.argv or " -n=" in args or args == "-c":
                        edgedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with edgedriver_fixing_lock:
                            if not _was_driver_repaired():
                                _repair_edgedriver(edge_version)
                                _mark_driver_repaired()
                    else:
                        if not _was_driver_repaired():
                            _repair_edgedriver(edge_version)
                        _mark_driver_repaired()
                    driver = Edge(
                        executable_path=LOCAL_EDGEDRIVER,
                        service_log_path=os.devnull,
                        service_args=["--disable-build-check"],
                        capabilities=capabilities,
                    )
                return driver
        elif browser_name == constants.Browser.SAFARI:
            from selenium.webdriver.safari.options import Options as SafariOptions
    
            arg_join = " ".join(sys.argv)
            if ("-n" in sys.argv) or (" -n=" in arg_join) or (arg_join == "-c"):
                # Skip if multithreaded
                raise Exception("Can't run Safari tests in multithreaded mode!")
            warnings.simplefilter("ignore", category=DeprecationWarning)
            service = SafariService(quiet=False)
            options = SafariOptions()
            if (
                selenium4_or_newer
                and page_load_strategy
                and page_load_strategy.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = page_load_strategy.lower()
            elif (
                selenium4_or_newer
                and not page_load_strategy
                and hasattr(settings, "PAGE_LOAD_STRATEGY")
                and settings.PAGE_LOAD_STRATEGY
                and settings.PAGE_LOAD_STRATEGY.lower() in ["eager", "none"]
            ):
                # Only change it if not "normal", which is the default.
                options.page_load_strategy = settings.PAGE_LOAD_STRATEGY.lower()
            return webdriver.safari.webdriver.WebDriver(
                service=service, options=options
            )
        elif browser_name == constants.Browser.OPERA:
            try:
                if LOCAL_OPERADRIVER and os.path.exists(LOCAL_OPERADRIVER):
                    try:
                        make_driver_executable_if_not(LOCAL_OPERADRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make operadriver"
                            " executable: %s" % e
                        )
                # Opera Chromium doesn't support headless mode.
                # https://github.com/operasoftware/operachromiumdriver/issues/62
                headless = False
                opera_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                warnings.simplefilter("ignore", category=DeprecationWarning)
                return webdriver.Opera(options=opera_options)
            except Exception:
                # Opera support was dropped! Downgrade to Python 3.6 to use it!
                return webdriver.Opera()
        elif browser_name == constants.Browser.GOOGLE_CHROME:
            try:
                chrome_options = _set_chrome_options(
                    browser_name,
                    downloads_path,
                    headless,
                    locale_code,
                    proxy_string,
                    proxy_auth,
                    proxy_user,
                    proxy_pass,
                    proxy_bypass_list,
                    proxy_pac_url,
                    multi_proxy,
                    user_agent,
                    recorder_ext,
                    disable_js,
                    disable_csp,
                    enable_ws,
                    enable_sync,
                    use_auto_ext,
                    undetectable,
                    uc_cdp_events,
                    uc_subprocess,
                    no_sandbox,
                    disable_gpu,
                    headless2,
                    incognito,
                    guest_mode,
                    devtools,
                    remote_debug,
                    enable_3d_apis,
                    swiftshader,
                    ad_block_on,
                    block_images,
                    do_not_track,
                    chromium_arg,
                    user_data_dir,
                    extension_zip,
                    extension_dir,
                    binary_location,
                    page_load_strategy,
                    use_wire,
                    external_pdf,
                    servername,
                    mobile_emulator,
                    device_width,
                    device_height,
                    device_pixel_ratio,
                )
                use_version = "latest"
                major_chrome_version = None
                if selenium4_or_newer:
                    try:
                        from seleniumbase.core import detect_b_ver
    
                        if binary_location:
                            try:
                                major_chrome_version = (
                                    detect_b_ver.get_browser_version_from_binary(
                                        binary_location
                                    )
                                ).split(".")[0]
                                if len(major_chrome_version) &lt; 2:
                                    major_chrome_version = None
                            except Exception:
                                major_chrome_version = None
                        if not major_chrome_version:
                            br_app = "google-chrome"
                            major_chrome_version = (
                                detect_b_ver.get_browser_version_from_os(br_app)
                            ).split(".")[0]
                        if int(major_chrome_version) &lt; 67:
                            major_chrome_version = None
                        elif (
                            int(major_chrome_version) &gt;= 67
                            and int(major_chrome_version) &lt;= 72
                        ):
                            # chromedrivers 2.41 - 2.46 could be swapped with 72
                            major_chrome_version = "72"
                    except Exception:
                        major_chrome_version = None
                if major_chrome_version:
                    use_version = major_chrome_version
                driver_version = None
                path_chromedriver = chromedriver_on_path()
                if os.path.exists(LOCAL_CHROMEDRIVER):
                    try:
                        output = subprocess.check_output(
                            "%s --version" % LOCAL_CHROMEDRIVER, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                elif path_chromedriver:
                    try:
                        output = subprocess.check_output(
                            "%s --version" % path_chromedriver, shell=True
                        )
                        if IS_WINDOWS:
                            output = output.decode("latin1")
                        else:
                            output = output.decode("utf-8")
                        output = output.split(" ")[1].split(".")[0]
                        if int(output) &gt;= 2:
                            driver_version = output
                    except Exception:
                        pass
                if headless2:
                    try:
                        if use_version == "latest" or int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        else:
                            chrome_options.add_argument("--headless=chrome")
                    except Exception:
                        chrome_options.add_argument("--headless=new")
                elif headless and undetectable:
                    try:
                        if int(use_version) &gt;= 109:
                            chrome_options.add_argument("--headless=new")
                        elif (
                            int(use_version) &gt;= 96
                            and int(use_version) &lt;= 108
                        ):
                            chrome_options.add_argument("--headless=chrome")
                        else:
                            pass  # Will need Xvfb on Linux
                    except Exception:
                        pass
                elif headless:
                    if "--headless" not in chrome_options.arguments:
                        chrome_options.add_argument("--headless")
                disable_build_check = False
                uc_driver_version = None
                if is_using_uc(undetectable, browser_name):
                    uc_driver_version = get_uc_driver_version()
                    if multi_proxy:
                        from seleniumbase import config as sb_config
    
                        sb_config.multi_proxy = True
                if (
                    LOCAL_CHROMEDRIVER
                    and os.path.exists(LOCAL_CHROMEDRIVER)
                    and (
                        use_version == driver_version
                        or use_version == "latest"
                    )
                    and (
                        not is_using_uc(undetectable, browser_name)
                        or not IS_ARM_MAC
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and uc_driver_version == use_version
                    )
                ):
                    try:
                        make_driver_executable_if_not(LOCAL_CHROMEDRIVER)
                    except Exception as e:
                        logging.debug(
                            "\nWarning: Could not make chromedriver"
                            " executable: %s" % e
                        )
                elif (
                    not path_chromedriver
                    or (
                        use_version != "latest"
                        and driver_version
                        and use_version != driver_version
                        and (
                            selenium4_or_newer
                            or driver_version != "72"
                        )
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and not os.path.exists(LOCAL_UC_DRIVER)
                    )
                    or (
                        is_using_uc(undetectable, browser_name)
                        and IS_ARM_MAC
                        and use_version != "latest"
                        and uc_driver_version != use_version
                    )
                ):
                    # chromedriver download needed in the seleniumbase/drivers dir
                    from seleniumbase.console_scripts import sb_install
    
                    args = " ".join(sys.argv)
                    if not ("-n" in sys.argv or " -n=" in args or args == "-c"):
                        # (Not multithreaded)
                        sys_args = sys.argv  # Save a copy of current sys args
                        msg = "chromedriver update needed. Getting it now:"
                        if not path_chromedriver:
                            msg = "chromedriver not found. Getting it now:"
                        print("\nWarning: %s" % msg)
                        intel_for_uc = False
                        if IS_ARM_MAC and is_using_uc(undetectable, browser_name):
                            intel_for_uc = True  # Use Intel's driver for UC Mode
                        try:
                            sb_install.main(
                                override="chromedriver %s" % use_version,
                                intel_for_uc=intel_for_uc,
                            )
                        except Exception:
                            d_latest = get_latest_chromedriver_version()
                            if (
                                d_latest
                                and use_version != "latest"
                                and int(use_version) &gt; int(d_latest.split(".")[0])
                            ):
                                disable_build_check = True
                                d_latest_major = d_latest.split(".")[0]
                                if (
                                    not path_chromedriver
                                    or (
                                        driver_version
                                        and (
                                            int(driver_version)
                                            &lt; int(d_latest_major)
                                        )
                                    )
                                ):
                                    sb_install.main(override="chromedriver latest")
                        sys.argv = sys_args  # Put back the original sys args
                    else:
                        # (Multithreaded)
                        chromedriver_fixing_lock = fasteners.InterProcessLock(
                            constants.MultiBrowser.DRIVER_FIXING_LOCK
                        )
                        with chromedriver_fixing_lock:
                            msg = "chromedriver update needed. Getting it now:"
                            if not path_chromedriver:
                                msg = "chromedriver not found. Getting it now:"
                            intel_for_uc = False
                            if (
                                IS_ARM_MAC
                                and is_using_uc(undetectable, browser_name)
                            ):
                                intel_for_uc = True  # Use Intel driver for UC Mode
                            if (
                                (
                                    not is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_CHROMEDRIVER)
                                )
                                or (
                                    is_using_uc(undetectable, browser_name)
                                    and not os.path.exists(LOCAL_UC_DRIVER)
                                )
                            ):
                                print("\nWarning: %s" % msg)
                                sys_args = sys.argv  # Save a copy of sys args
                                try:
                                    sb_install.main(
                                        override="chromedriver %s" % use_version,
                                        intel_for_uc=intel_for_uc,
                                    )
                                except Exception:
                                    d_latest = get_latest_chromedriver_version()
                                    if (
                                        d_latest
                                        and use_version != "latest"
                                        and (
                                            int(use_version)
                                            &gt; int(d_latest.split(".")[0])
                                        )
                                    ):
                                        disable_build_check = True
                                        d_latest_major = d_latest.split(".")[0]
                                        if (
                                            not path_chromedriver
                                            or (
                                                driver_version
                                                and (
                                                    int(driver_version)
                                                    &lt; int(d_latest_major)
                                                )
                                            )
                                        ):
                                            sb_install.main(
                                                override="chromedriver latest"
                                            )
                                finally:
                                    sys.argv = sys_args  # Put back original args
                service_args = []
                if disable_build_check:
                    service_args = ["--disable-build-check"]
                if is_using_uc(undetectable, browser_name):
                    uc_lock = fasteners.InterProcessLock(
                        constants.MultiBrowser.DRIVER_FIXING_LOCK
                    )
                    with uc_lock:  # Avoid multithreaded issues
                        uc_driver_version = get_uc_driver_version()
                        if (
                            (
                                uc_driver_version != use_version
                                and use_version != "latest"
                            )
                            or not os.path.exists(LOCAL_UC_DRIVER)
                        ):
                            if IS_ARM_MAC and os.path.exists(LOCAL_UC_DRIVER):
                                pass  # Already taken care of in sb_install
                            elif os.path.exists(LOCAL_CHROMEDRIVER):
                                shutil.copyfile(
                                    LOCAL_CHROMEDRIVER, LOCAL_UC_DRIVER
                                )
                            elif os.path.exists(path_chromedriver):
                                shutil.copyfile(
                                    path_chromedriver, LOCAL_UC_DRIVER
                                )
                            try:
                                make_driver_executable_if_not(LOCAL_UC_DRIVER)
                            except Exception as e:
                                logging.debug(
                                    "\nWarning: Could not make uc_driver"
                                    " executable: %s" % e
                                )
                if (
                    not headless
                    or not IS_LINUX
                    or is_using_uc(undetectable, browser_name)
                ):
                    try:
                        if (
                            os.path.exists(LOCAL_CHROMEDRIVER)
                            or is_using_uc(undetectable, browser_name)
                        ):
                            if selenium4_or_newer:
                                if headless and not IS_LINUX:
                                    undetectable = False  # No support for headless
                                if is_using_uc(undetectable, browser_name):
                                    from seleniumbase import undetected
                                    from urllib.error import URLError
    
                                    if IS_LINUX:
                                        if "--headless" in (
                                            chrome_options.arguments
                                        ):
                                            chrome_options.arguments.remove(
                                                "--headless"
                                            )
                                    uc_chrome_version = None
                                    if (
                                        use_version.isnumeric()
                                        and int(use_version) &gt;= 72
                                    ):
                                        uc_chrome_version = int(use_version)
                                    cdp_events = uc_cdp_events
                                    cert = "unable to get local issuer certificate"
                                    mac_certificate_error = False
                                    try:
                                        uc_path = None
                                        if os.path.exists(LOCAL_UC_DRIVER):
                                            uc_path = LOCAL_UC_DRIVER
                                            uc_path = os.path.realpath(uc_path)
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                    except URLError as e:
                                        if cert in e.args[0] and IS_MAC:
                                            mac_certificate_error = True
                                        else:
                                            raise
                                    if mac_certificate_error:
                                        cf_lock_path = (
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        cf_lock = fasteners.InterProcessLock(
                                            constants.MultiBrowser.CERT_FIXING_LOCK
                                        )
                                        if not os.path.exists(cf_lock_path):
                                            # Avoid multithreaded issues
                                            with cf_lock:
                                                # Install Python Certificates (MAC)
                                                os.system(
                                                    r"bash /Applications/Python*/"
                                                    r"Install\ "
                                                    r"Certificates.command"
                                                )
                                        driver = undetected.Chrome(
                                            options=chrome_options,
                                            user_data_dir=user_data_dir,
                                            driver_executable_path=uc_path,
                                            browser_executable_path=b_path,
                                            enable_cdp_events=cdp_events,
                                            headless=False,  # Xvfb needed!
                                            version_main=uc_chrome_version,
                                            use_subprocess=True,  # Always!
                                        )
                                else:
                                    service = ChromeService(
                                        executable_path=LOCAL_CHROMEDRIVER,
                                        log_path=os.devnull,
                                        service_args=service_args,
                                    )
&gt;                                   driver = webdriver.Chrome(
                                        service=service,
                                        options=chrome_options,
                                    )

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, executable_path = 'chromedriver', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10bf54550&gt;, service_args = None, desired_capabilities = None
service_log_path = None, chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106ff9bd0&gt;
keep_alive = True

    def __init__(
        self,
        executable_path=DEFAULT_EXECUTABLE_PATH,
        port=DEFAULT_PORT,
        options: Options = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        chrome_options=None,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        if executable_path != "chromedriver":
            warnings.warn(
                "executable_path has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        if chrome_options:
            warnings.warn("use options instead of chrome_options", DeprecationWarning, stacklevel=2)
            options = chrome_options
        if keep_alive != DEFAULT_KEEP_ALIVE:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
        if not options:
            options = self.create_options()
        if not service:
            service = Service(executable_path, port, service_args, service_log_path)
        service.path = DriverFinder.get_path(service, options)
    
&gt;       super().__init__(
            DesiredCapabilities.CHROME["browserName"],
            "goog",
            port,
            options,
            service_args,
            desired_capabilities,
            service_log_path,
            service,
            keep_alive,
        )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, browser_name = 'chrome', vendor_prefix = 'goog', port = 0
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10bf54550&gt;, service_args = None, desired_capabilities = None
service_log_path = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x106ff9bd0&gt;, keep_alive = True

    def __init__(
        self,
        browser_name,
        vendor_prefix,
        port=DEFAULT_PORT,
        options: BaseOptions = None,
        service_args=None,
        desired_capabilities=None,
        service_log_path=DEFAULT_SERVICE_LOG_PATH,
        service: Service = None,
        keep_alive=DEFAULT_KEEP_ALIVE,
    ) -&gt; None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.
         - options - this takes an instance of ChromiumOptions
         - service_args - Deprecated: List of args to pass to the driver service
         - desired_capabilities - Deprecated: Dictionary object with non-browser specific
           capabilities only, such as "proxy" or "loggingPref".
         - service_log_path - Deprecated: Where to log information from the driver.
         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if port != DEFAULT_PORT:
            warnings.warn("port has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2)
        self.port = port
        if service_log_path != DEFAULT_SERVICE_LOG_PATH:
            warnings.warn(
                "service_log_path has been deprecated, please pass in a Service object",
                DeprecationWarning,
                stacklevel=2,
            )
        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:
            warnings.warn(
                "keep_alive has been deprecated, please pass in a Service object", DeprecationWarning, stacklevel=2
            )
        else:
            keep_alive = True
    
        self.vendor_prefix = vendor_prefix
    
        _ignore_proxy = None
        if not options:
            options = self.create_options()
    
        if desired_capabilities:
            for key, value in desired_capabilities.items():
                options.set_capability(key, value)
    
        if options._ignore_local_proxy:
            _ignore_proxy = options._ignore_local_proxy
    
        if not service:
            raise AttributeError("service cannot be None")
    
        self.service = service
        self.service.start()
    
        try:
&gt;           super().__init__(
                command_executor=ChromiumRemoteConnection(
                    remote_server_addr=self.service.service_url,
                    browser_name=browser_name,
                    vendor_prefix=vendor_prefix,
                    keep_alive=keep_alive,
                    ignore_proxy=_ignore_proxy,
                ),
                options=options,
            )

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
command_executor = &lt;selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x10bf559d0&gt;
desired_capabilities = None, browser_profile = None, proxy = None, keep_alive = True, file_detector = None
options = &lt;selenium.webdriver.chrome.options.Options object at 0x10bf54550&gt;

    def __init__(
        self,
        command_executor="http://127.0.0.1:4444",
        desired_capabilities=None,
        browser_profile=None,
        proxy=None,
        keep_alive=True,
        file_detector=None,
        options: Union[BaseOptions, List[BaseOptions]] = None,
    ) -&gt; None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        :Args:
         - command_executor - Either a string representing URL of the remote server or a custom
             remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
         - desired_capabilities - A dictionary of capabilities to request when
             starting the browser session. Required parameter.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
             Only used if Firefox is requested. Optional.
         - proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
             be started with given proxy settings, if possible. Optional.
         - keep_alive - Whether to configure remote_connection.RemoteConnection to use
             HTTP keep-alive. Defaults to True.
         - file_detector - Pass custom file detector object during instantiation. If None,
             then default LocalFileDetector() will be used.
         - options - instance of a driver options.Options class
        """
        if desired_capabilities:
            warnings.warn(
                "desired_capabilities has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if browser_profile:
            warnings.warn(
                "browser_profile has been deprecated, please pass in an Firefox Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if proxy:
            warnings.warn(
                "proxy has been deprecated, please pass in an Options object with options kwarg",
                DeprecationWarning,
                stacklevel=2,
            )
        if not keep_alive:
            warnings.warn(
                "keep_alive has been deprecated. We will be using True as the default value as we start removing it.",
                DeprecationWarning,
                stacklevel=2,
            )
        capabilities = {}
        # If we get a list we can assume that no capabilities
        # have been passed in
        if isinstance(options, list):
            capabilities = create_matches(options)
        else:
            _ignore_local_proxy = False
            if options:
                capabilities = options.to_capabilities()
                _ignore_local_proxy = options._ignore_local_proxy
            if desired_capabilities:
                if not isinstance(desired_capabilities, dict):
                    raise WebDriverException("Desired Capabilities must be a dictionary")
                capabilities.update(desired_capabilities)
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self._authenticator_id = None
        self.start_client()
&gt;       self.start_session(capabilities, browser_profile)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '--ignore-certificate-errors', '--...lt_content_setting_values.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}
browser_profile = None

    def start_session(self, capabilities: dict, browser_profile=None) -&gt; None:
        """Creates a new session with the desired capabilities.
    
        :Args:
         - capabilities - a capabilities dict to start the session with.
         - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
        """
        if not isinstance(capabilities, dict):
            raise InvalidArgumentException("Capabilities must be a dictionary")
        if browser_profile:
            if "moz:firefoxOptions" in capabilities:
                capabilities["moz:firefoxOptions"]["profile"] = browser_profile.encoded
            else:
                capabilities.update({"firefox_profile": browser_profile.encoded})
        w3c_caps = _make_w3c_caps(capabilities)
        parameters = {"capabilities": w3c_caps}
&gt;       response = self.execute(Command.NEW_SESSION, parameters)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="None")&gt;, driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--window-size=1280,840', '...ues.notifications': 0, 'default_content_settings.popups': 0, ...}}, 'pageLoadStrategy': 'normal'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -&gt; dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
&gt;           self.error_handler.check_response(response)

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10bf577d0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created\\nfrom unknown error:...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created
E       from unknown error: result.webdriverValue.value list is missing or empty in Runtime.callFunctionOn response
E         (Session info: chrome=120.0.6099.234)
E       Stacktrace:
E       0   chromedriver                        0x0000000104eabf48 chromedriver + 4226888
E       1   chromedriver                        0x0000000104ea44f4 chromedriver + 4195572
E       2   chromedriver                        0x0000000104ae8d68 chromedriver + 281960
E       3   chromedriver                        0x0000000104aed114 chromedriver + 299284
E       4   chromedriver                        0x0000000104aeefe4 chromedriver + 307172
E       5   chromedriver                        0x0000000104aef0d4 chromedriver + 307412
E       6   chromedriver                        0x0000000104b4c7c4 chromedriver + 690116
E       7   chromedriver                        0x0000000104b4b164 chromedriver + 684388
E       8   chromedriver                        0x0000000104b17f1c chromedriver + 474908
E       9   chromedriver                        0x0000000104b18ef4 chromedriver + 478964
E       10  chromedriver                        0x0000000104e6d59c chromedriver + 3970460
E       11  chromedriver                        0x0000000104e716f0 chromedriver + 3987184
E       12  chromedriver                        0x0000000104e775b4 chromedriver + 4011444
E       13  chromedriver                        0x0000000104e722fc chromedriver + 3990268
E       14  chromedriver                        0x0000000104e4a1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000104e8e088 chromedriver + 4104328
E       16  chromedriver                        0x0000000104e8e1e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000104e9df28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException

During handling of the above exception, another exception occurred:

self = &lt;seleniumbase.fixtures.unittest_helper._Outcome object at 0x10bf56350&gt;
test_case = &lt;tests.boilerplates.samples.swag_labs_test.MyTests testMethod=test_swag_labs_login&gt;, isTest = False

    @contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
&gt;           yield

/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/unittest_helper.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:14846: in run
    self._callSetUp()
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:13820: in setUp
    self.driver = self.get_new_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/fixtures/base_case.py:3783: in get_new_driver
    new_driver = browser_launcher.get_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:1234: in get_driver
    return get_local_driver(
/opt/homebrew/lib/python3.11/site-packages/seleniumbase/core/browser_launcher.py:3346: in get_local_driver
    return webdriver.Chrome()
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chrome/webdriver.py:84: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/chromium/webdriver.py:104: in __init__
    super().__init__(
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:286: in __init__
    self.start_session(capabilities, browser_profile)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:378: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10bf558d0&gt;
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: This version of Chro...000181986034 _pthread_start + 136\\n19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114
E       Current browser version is 120.0.6099.234 with binary path /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
E       Stacktrace:
E       0   chromedriver                        0x000000010253ff48 chromedriver + 4226888
E       1   chromedriver                        0x00000001025384f4 chromedriver + 4195572
E       2   chromedriver                        0x000000010217cd68 chromedriver + 281960
E       3   chromedriver                        0x00000001021a8bac chromedriver + 461740
E       4   chromedriver                        0x00000001021a4fd8 chromedriver + 446424
E       5   chromedriver                        0x00000001021a2150 chromedriver + 434512
E       6   chromedriver                        0x00000001021df93c chromedriver + 686396
E       7   chromedriver                        0x00000001021df164 chromedriver + 684388
E       8   chromedriver                        0x00000001021abf1c chromedriver + 474908
E       9   chromedriver                        0x00000001021acef4 chromedriver + 478964
E       10  chromedriver                        0x000000010250159c chromedriver + 3970460
E       11  chromedriver                        0x00000001025056f0 chromedriver + 3987184
E       12  chromedriver                        0x000000010250b5b4 chromedriver + 4011444
E       13  chromedriver                        0x00000001025062fc chromedriver + 3990268
E       14  chromedriver                        0x00000001024de1c0 chromedriver + 3826112
E       15  chromedriver                        0x0000000102522088 chromedriver + 4104328
E       16  chromedriver                        0x00000001025221e0 chromedriver + 4104672
E       17  chromedriver                        0x0000000102531f28 chromedriver + 4169512
E       18  libsystem_pthread.dylib             0x0000000181986034 _pthread_start + 136
E       19  libsystem_pthread.dylib             0x0000000181980e3c thread_start + 8

/opt/homebrew/lib/python3.11/site-packages/selenium/webdriver/remote/errorhandler.py:245: SessionNotCreatedException</failure></testcase></testsuite></testsuites>